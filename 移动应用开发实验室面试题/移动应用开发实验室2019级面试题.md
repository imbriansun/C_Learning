# 移动应用开发实验室2019级面试题

<u>以下程序均通过`gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)`编译运行</u>

#### <u>3.1</u>

```c
int x,y,m,n;
x = 0;
y = 1;
m = x, y;
n = (x, y);
printf("%d ", m);
printf("%d\n", n);
```



###### 输出结果：

`0 1`

###### 考点：

逗号运算符，赋值运算符，括号运算符

![Gyxs6e.jpg](https://s1.ax1x.com/2020/04/06/Gyxs6e.jpg)



###### 分析：



逗号运算符，优先级别最低，双目运算符，运算顺序从左向右，但最后返回值是整个逗号表达式是最后一个表达式的值



m = x, y;		相当于(m=x),y;

赋值运算符的运算优先级是大于逗号运算符优先级的，因此先执行m=x运算，m被赋于0

再执行y表达式



n = (x, y);

括号优先级又高于赋值号优先级，因此先执行括号内语句，括号内逗号表达式的运算结果（返回值）是y的值  `1`  ，再将  `1`  赋于n



因此最终结果为 `0 1`





###### **扩展：**

C语言中的所有运算符：

除了常见的三大类，算数运算符、关系运算符与逻辑运算符之外，还有一些用于完成特殊任务的运算符，比如位运算符。



- [ ] CPP总结
- [ ] 3G公众号上有关运算符





#### <u>3.2</u>

```c
int x=3;
int y=4;
int a = x++ + x++ + x++;
int b = ++y + ++y + ++y;
printf("%d, %d\n", a, b);
```



###### 输出结果：

`12 ， 19`



###### 分析：

对于自增/自减的后缀运算符，返回值返回自增/自减前的数值，前缀运算符反之，但结束该语句后，下一次用到上次进行过自增/自减运算符的变量是自增/自减后的值。

++ x（即增量运算符）使用“先更改后使用”原理，而x ++（即增量运算符）则使用“先使用再更改”原理。



本题一共有三种运算符，赋值运算符 `=`   自增运算符 `++`  二元加法运算符 `+`

优先级 `++` （后缀）  >  `++`  （前缀）>  `+`  >  `=`



###### 错解：

~~那么对于a来说，自左向右：~~

~~x++执行，返回3，但此时x=4~~

~~x++执行，返回4，但此时x=5~~

~~x++执行，返回5，但此时x=6~~

~~a=3+4+5~~

~~a=12~~



~~对于b：~~

~~++y执行，返回5，此时y=5~~

~~++y执行，返回6，此时y=6~~

~~++y执行，返回7，此时y=7~~

~~b=5+6+7~~

~~b=18**~~**



**以上划线解释全错！**



###### **正解：**

像上述表达式是<u>**未定义**</u>的！

以下来自C和指针 5.4.4优先级和计值顺序章节

![G61Wse.png](https://s1.ax1x.com/2020/04/06/G61Wse.png)
![G61gxO.png](https://s1.ax1x.com/2020/04/06/G61gxO.png)
![G61cRK.png](https://s1.ax1x.com/2020/04/06/G61cRK.png)
![G61yPx.png](https://s1.ax1x.com/2020/04/06/G61yPx.png)
![G61rI1.png](https://s1.ax1x.com/2020/04/06/G61rI1.png)







###### **解决方案：**

```c
int x=3;
int y=4;
int a = x++;
a+=x++;
a+=x++;

int b = ++y ;
b+=++y;
b+=++y;

printf("%d, %d\n", a, b);
```

输出结果：

![G68u7j.png](https://s1.ax1x.com/2020/04/06/G68u7j.png)





###### **参考资料**：

中文版：https://cloud.tencent.com/developer/section/1009054

英文版：C和指针（Pointers On C）





###### **拓展**

C++中：https://en.cppreference.com/w/cpp/language/eval_order

![G6Qsm9.png](https://s1.ax1x.com/2020/04/06/G6Qsm9.png)







- [ ] C专家编程/C缺陷--为什么++/--会有前缀后缀之分？





#### <u>3.3</u>

```c
struct node
{
int x; int y; int z;
};
struct one a = { 1, 10, 100 };
struct node *p = &a;
printf("%d\n", *(int*)p);
```

###### 输出结果：

`1`



###### 考点：

字节对齐：https://shimo.im/docs/ydYJdGQqkHhV6ckP/ 

强制类型转换

大小端



###### 分析：

对齐数：Linux下为4 Windows 的 VS 下为 8 （不一定，可通过`#pragma pack(x)` 控制） ，第二个成员大小为4 对齐数取4

Linux下为4 Windows 的 VS 下为 8（不一定，可通过`#pragma pack(x)` 控制） ，第三个成员大小为4 对齐数取4

![G6YHKK.png](https://s1.ax1x.com/2020/04/06/G6YHKK.png)



#### 3.4：

```c
struct B{
int a;
char b;
double c;
};
struct A{
char a;double b;
int c;
};
struct C{
char a;
double b;
struct A c;
int d;
};
int main(){
printf("%d,%d\n",sizeof(struct A),sizeof(struct B));
printf("%d",sizeof(struct C));
}
```

###### 输出结果：

`24,16`

`48`



###### 考点：

字节对齐

**转换规则：**

1. 第一个成员在与结构体变量偏移量为0的地址处。 

2. 其他的**每一个**成员变量（非嵌套结构体）要对齐到某个数字（对齐数）的整数倍的地址处。 

   

   当成员是数组时，该成员的对齐数是一个数组元素的大小 

   如果嵌套了结构体的情况，嵌套的结构体对齐到**自己成员**的最大对齐数的整数倍处。（就算自己成员对齐数都小于编译器默认对齐数也不取编译器默认对齐数而取成员对齐数中最大的） 

   **对齐数 = 编译器默认的一个对齐数 与 该成员大小 的**较小值。

    VS中默认的值为8 Linux中的默认值为4（这个不一定 可以用#pragma pack(x) 修改x确定编译器默认对齐数x 默认参数只能设置成1，2，4，8，16） 

   

3.  结构体总大小为所有成员中的**最大**对齐数的整数倍。如果这个结构体成员中含嵌套结构体的话，嵌套结构体作为结构体成员取嵌套体内成员最大对齐数作为嵌套结构体对齐数，那么结构体总大小为这些对齐数中最大的那个整数倍



###### 解析：

**对于结构体 sizeof A、B的求值是同理的**

![G6aEIe.png](https://s1.ax1x.com/2020/04/07/G6aEIe.png)

**对于结构体内嵌套结构体的struct C来说，其大小为：48**

![G60YJe.jpg](https://s1.ax1x.com/2020/04/07/G60YJe.jpg)







#### 3.5

```c
int i = 1;
printf("%d %d %d", i ,++i,i++);
```



###### 输出结果：

`3 3 1`



分析：





#### 3.6

```c
printf("g%c",printf("%d",printf("XY!")));
```

###### 输出结果：

`XY!3gctrl^A`     ![GcA0TU.png](https://s1.ax1x.com/2020/04/07/GcA0TU.png)

ctrl^A是ASCII 中 `1`  对应的字符，是不可打印字符



###### 考点：

printf返回值

printf()函数原型：int printf (char* format, args, ...)

返回值为传到输出流的字符数（不包含终止字符NULL（'\0'））



###### 解析：

嵌套括号先从最内层括号开始执行，先`printf("XY!")`打印出`XY!`，返回值`3`，再执行`printf("%d",3)`，打印出`3`，返回值为`1`，再执行`printf("g%c",1);`，打印出`g`和`ctrl^A`



#### 3.7

```c
struct perInfo1{
int num;
char name[10];
double account;
};

struct perInfo2{
char name[10];
double account;
int num;
};

int main()
{
    struct perInfo1 Tony1 = {1,"Tony",3.14159};
    int structSize1 = sizeof(struct perInfo1);
    struct perInfo2 Tony2 = {"Tony",3.14159,1};
    int structSize2 = sizeof(struct perInfo2);
    printf("Size : { int, char[10], double } = %d\n",structSize1);
    printf("Size : { char[10], double, int } = %d\n",structSize2);
    return 0;
}
```

###### 输出结果：

```c
当最前加#pragma pack(8) 让编译器默认对齐数为8：
Size : { int, char[10], double } = 24
Size : { char[10], double, int } = 32
    
当最前加#pragma pack(4) 让编译器默认对齐数为4：
Size : { int, char[10], double } = 24
Size : { char[10], double, int } = 24
```

###### 解析：

当编译器默认对齐数为8：`#pragma pack(8)`

[![GcO6iV.md.jpg](https://s1.ax1x.com/2020/04/07/GcO6iV.md.jpg)](https://imgchr.com/i/GcO6iV)



![GcOWM4.jpg](https://s1.ax1x.com/2020/04/07/GcOWM4.jpg)

###### 字节对齐总结

https://shimo.im/docs/ydYJdGQqkHhV6ckP/ 



#### 3.8

```c
int main()
{
	int a[4] [3]={1,2,3,4,5,6,7,8,9,10,11,12};
	// 假设 a的首地址为0x0000000000000000
    printf("%p,%p\n",a,a+1);
    printf("%p,%p\n",a[0],a[0]+1);
    printf("%p,%p\n",*a,*a+1);
    printf("%d\n",a[0] [0]);
    printf("%d,%d\n",*a[0],*(a[0]+1));
    printf("%d\n",**a);
    printf("%d\n",* (*(a+3)+1));
    
}
```

###### 输出结果：

```c
0x0000000000000000	0x000000000000001c
0x0000000000000000  0x0000000000000004
0x0000000000000000  0x0000000000000004    
1
1,2
1
11
```

###### 考点：

指针的加减



分析：
