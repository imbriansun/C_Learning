# 移动应用开发实验室2019级面试题

<u>以下程序均通过`gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1)`编译运行</u>

## <u>3.1</u>

```c
int x,y,m,n;
x = 0;
y = 1;
m = x, y;
n = (x, y);
printf("%d ", m);
printf("%d\n", n);
```



###### 输出结果：

`0 1`

###### 考点：

逗号运算符，赋值运算符，括号运算符

![Gyxs6e.jpg](https://s1.ax1x.com/2020/04/06/Gyxs6e.jpg)



###### 分析：



逗号运算符，优先级别最低，双目运算符，运算顺序从左向右，但最后返回值是整个逗号表达式是最后一个表达式的值



m = x, y;		相当于(m=x),y;

赋值运算符的运算优先级是大于逗号运算符优先级的，因此先执行m=x运算，m被赋于0

再执行y表达式



n = (x, y);

括号优先级又高于赋值号优先级，因此先执行括号内语句，括号内逗号表达式的运算结果（返回值）是y的值  `1`  ，再将  `1`  赋于n



因此最终结果为 `0 1`





###### **扩展：**

C语言中的所有运算符：

除了常见的三大类，算数运算符、关系运算符与逻辑运算符之外，还有一些用于完成特殊任务的运算符，比如位运算符。



- [ ] CPP总结
- [ ] 3G公众号上有关运算符





## <u>3.2</u>

```c
int x=3;
int y=4;
int a = x++ + x++ + x++;
int b = ++y + ++y + ++y;
printf("%d, %d\n", a, b);
```



###### 输出结果：

`12 ， 19`



###### 分析：

对于自增/自减的后缀运算符，返回值返回自增/自减前的数值，前缀运算符反之，但结束该语句后，下一次用到上次进行过自增/自减运算符的变量是自增/自减后的值。

++ x（即增量运算符）使用“先更改后使用”原理，而x ++（即增量运算符）则使用“先使用再更改”原理。



本题一共有三种运算符，赋值运算符 `=`   自增运算符 `++`  二元加法运算符 `+`

优先级 `++` （后缀）  >  `++`  （前缀）>  `+`  >  `=`



###### 错解：

~~那么对于a来说，自左向右：~~

~~x++执行，返回3，但此时x=4~~

~~x++执行，返回4，但此时x=5~~

~~x++执行，返回5，但此时x=6~~

~~a=3+4+5~~

~~a=12~~



~~对于b：~~

~~++y执行，返回5，此时y=5~~

~~++y执行，返回6，此时y=6~~

~~++y执行，返回7，此时y=7~~

~~b=5+6+7~~

~~b=18**~~**



**以上划线解释全错！**



###### **正解：**

像上述表达式是<u>**未定义**</u>的！

以下来自C和指针 5.4.4优先级和计值顺序章节

![G61Wse.png](https://s1.ax1x.com/2020/04/06/G61Wse.png)
![G61gxO.png](https://s1.ax1x.com/2020/04/06/G61gxO.png)
![G61cRK.png](https://s1.ax1x.com/2020/04/06/G61cRK.png)
![G61yPx.png](https://s1.ax1x.com/2020/04/06/G61yPx.png)
![G61rI1.png](https://s1.ax1x.com/2020/04/06/G61rI1.png)







###### **解决方案：**

```c
int x=3;
int y=4;
int a = x++;
a+=x++;
a+=x++;

int b = ++y ;
b+=++y;
b+=++y;

printf("%d, %d\n", a, b);
```

输出结果：

![G68u7j.png](https://s1.ax1x.com/2020/04/06/G68u7j.png)





###### **参考资料**：

中文版：https://cloud.tencent.com/developer/section/1009054

英文版：C和指针（Pointers On C）





###### **拓展**

C++中：https://en.cppreference.com/w/cpp/language/eval_order

![G6Qsm9.png](https://s1.ax1x.com/2020/04/06/G6Qsm9.png)







- [ ] C专家编程/C缺陷--为什么++/--会有前缀后缀之分？





## <u>3.3</u>

```c
struct node
{
int x; int y; int z;
};
struct one a = { 1, 10, 100 };
struct node *p = &a;
printf("%d\n", *(int*)p);
```

###### 输出结果：

`1`



###### 考点：

字节对齐：https://shimo.im/docs/ydYJdGQqkHhV6ckP/ 

强制类型转换

大小端



###### 分析：

对齐数：Linux下为4 Windows 的 VS 下为 8 （不一定，可通过`#pragma pack(x)` 控制） ，第二个成员大小为4 对齐数取4

Linux下为4 Windows 的 VS 下为 8（不一定，可通过`#pragma pack(x)` 控制） ，第三个成员大小为4 对齐数取4

![G6YHKK.png](https://s1.ax1x.com/2020/04/06/G6YHKK.png)



## 3.4：

```c
struct B{
int a;
char b;
double c;
};
struct A{
char a;double b;
int c;
};
struct C{
char a;
double b;
struct A c;
int d;
};
int main(){
printf("%d,%d\n",sizeof(struct A),sizeof(struct B));
printf("%d",sizeof(struct C));
}
```

###### 输出结果：

`24,16`

`48`



###### 考点：

字节对齐

**转换规则：**

1. 第一个成员在与结构体变量偏移量为0的地址处。 

2. 其他的**每一个**成员变量（非嵌套结构体）要对齐到某个数字（对齐数）的整数倍的地址处。 

   

   当成员是数组时，该成员的对齐数是一个数组元素的大小 

   如果嵌套了结构体的情况，嵌套的结构体对齐到**自己成员**的最大对齐数的整数倍处。（就算自己成员对齐数都小于编译器默认对齐数也不取编译器默认对齐数而取成员对齐数中最大的） 

   **对齐数 = 编译器默认的一个对齐数 与 该成员大小 的**较小值。

    VS中默认的值为8 Linux中的默认值为4（这个不一定 可以用#pragma pack(x) 修改x确定编译器默认对齐数x 默认参数只能设置成1，2，4，8，16） 

   

3.  结构体总大小为所有成员中的**最大**对齐数的整数倍。如果这个结构体成员中含嵌套结构体的话，嵌套结构体作为结构体成员取嵌套体内成员最大对齐数作为嵌套结构体对齐数，那么结构体总大小为这些对齐数中最大的那个整数倍



###### 解析：

**对于结构体 sizeof A、B的求值是同理的**

![G6aEIe.png](https://s1.ax1x.com/2020/04/07/G6aEIe.png)

**对于结构体内嵌套结构体的struct C来说，其大小为：48**

![G60YJe.jpg](https://s1.ax1x.com/2020/04/07/G60YJe.jpg)







## 3.5

```c
int i = 1;
printf("%d %d %d", i ,++i,i++);
```

### ！！！待http://www.c-faq.com/expr/seqpoints.htmlhttp://www.c-faq.com/expr/evalorder2.html

###### 输出结果：



###### 输出结果

`3 3 1`

###### 考点：

未定义行为

###### 分析：

首先我们先明白一个点，C语言中有许多行为是未定义的。

C语言中会有三个这样类似的点[implementation-defined, unspecified, and undefined behavior.](http://www.c-faq.com/ansi/undef.html)



首先我们先明确一点，参数入栈顺序和参数计值顺序无关

再一个，参数计值顺序是未定义的	undefined behavior  （UB）

> https://stackoverflow.com/questions/22616986/order-of-evaluation-of-arguments-in-function-calling
>
> 
>
> What the C standard says is that *the C standard itself* does not define the order of evaluation. Some secondary standard is still free to do so.
>
> Incidentally, this does not by itself involve undefined behavior. There are cases where the unspecified order of evaluation *can* lead to undefined behavior, for example:
>
> ```c
> printf("%d %d\n", i++, i++); /* undefined behavior! */
> ```
>
>  it is UB because you don't know the order of increments and the time of storing the incremented values. Assuming `i==0` prior to the instruction all results (0,0), (0,1) and (1,0) are possible. 
>
> 



parameter:参数

convention:条例 公约



a[i]=i++;

printf("%d%d",i++,i--);

这样的都是编译器未定义的，引用[implementation-defined, unspecified, and undefined behavior.](http://www.c-faq.com/ansi/undef.html)

的话就是

> ignore (that is, avoid worrying about generating correct code for) certain marginal constructs which are too difficult to define precisely and which probably aren't useful to well-written programs anyway
>
> 对于未定义的行为编译器可为了可移植性进行自己规定，编译器也可选择忽略这样的未定义（尽管可能引发考虑代码是否正确），原因是这样的代码一是难以被人/编译器定义，不同人也有不同观点，并且这对编写好的代码也没什么用
>
> 
>
> **implementation-defined:** The implementation must pick some behavior; it **may not fail to compile** the program. (The program using the construct is not incorrect.) The choice must be documented. The Standard may specify a set of allowable behaviors from which to choose, or it may impose no particular requirements.
>
> **unspecified:** Like implementation-defined, except that the choice need not be documented.
>
> **undefined:** **Anything at all can happen**; the Standard imposes no requirements. The program may fail to compile, or it may execute incorrectly (either crashing or silently generating incorrect results), or it may fortuitously do exactly what the programmer intended.
>
> Note, too, that since the Standard imposes absolutely no requirements on the behavior of a compiler faced with an instance of undefined behavior, the compiler (more importantly, any generated code) can do absolutely anything. In particular, there is no guarantee that at most the undefined bit of the program will behave badly, and that the rest of the program will perform normally. It's perilous to think that you can tolerate undefined behavior in a program, imagining that its undefinedness can't hurt; the undefined behavior can be more undefined than you think it can. (See question [3.2](http://www.c-faq.com/expr/evalorder2.html) for a relatively simple example.)
>
> Since many people seem to have trouble comprehending the depths to which undefined behavor can descend, it is traditional to come up with eye-catching, outrageous examples. Undefined means that, notwithstanding question [9.2](http://www.c-faq.com/bool/bool2.html), `printf("%d", j++ <= j);` can print 42, or ``forty-two.''
>
> If you're interested in writing portable code, you can ignore the distinctions, as you'll usually want to avoid code that depends on any of the three behaviors.
>
> See also questions [3.9](http://www.c-faq.com/expr/evalorder4.html), and [11.34](http://www.c-faq.com/ansi/appalled.html).
>
> (A fourth defined class of not-quite-precisely-defined behavior, without the same stigma attached to it, is [locale-specific](http://www.c-faq.com/sx1/index.html#locale-specific).)
>
> 总之：不要写类似的代码，也不好移植



###### 拓展：

一、

Under my compiler, the code

```
int i = 7;
printf("%d\n", i++ * i++);
```

prints 49. Regardless of the order of evaluation, shouldn't it print 56?

[answer](http://www.c-faq.com/expr/evalorder2.html)

> 对于`++`，`-`，`=`，`+ =`， `-=`等这样的运算符都是unspecified的 会有side effects（外加小型）



二、

["Is printf sensitive to the order of arguments?"](https://stackoverflow.com/questions/34411303/is-printf-sensitive-to-the-order-of-arguments)

![G2ZvNV.png](https://s1.ax1x.com/2020/04/07/G2ZvNV.png)

![G28wWR.png](https://s1.ax1x.com/2020/04/07/G28wWR.png)



![G2mboq.png](https://s1.ax1x.com/2020/04/07/G2mboq.png)





## 3.6

```c
printf("g%c",printf("%d",printf("XY!")));
```

###### 输出结果：

`XY!3gctrl^A`     ![GcA0TU.png](https://s1.ax1x.com/2020/04/07/GcA0TU.png)

ctrl^A是ASCII 中 `1`  对应的字符，是不可打印字符



###### 考点：

printf返回值

printf()函数原型：int printf (char* format, args, ...)

返回值为传到输出流的字符数（不包含终止字符NULL（'\0'））

`On success, the total number of characters written is returned. If a writing error occurs, the error indicator (ferror) is set and a negative number is returned. If a multibyte character encoding error occurs while writing wide characters, errno is set to EILSEQ and a negative number is returned.`

`If successful, the total number of characters written is returned. On failure, a negative number is returned.`

###### 解析：

嵌套括号先从最内层括号开始执行，先`printf("XY!")`打印出`XY!`，返回值`3`，再执行`printf("%d",3)`，打印出`3`，返回值为`1`，再执行`printf("g%c",1);`，打印出`g`和`ctrl^A`



## 3.7

```c
struct perInfo1{
int num;
char name[10];
double account;
};

struct perInfo2{
char name[10];
double account;
int num;
};

int main()
{
    struct perInfo1 Tony1 = {1,"Tony",3.14159};
    int structSize1 = sizeof(struct perInfo1);
    struct perInfo2 Tony2 = {"Tony",3.14159,1};
    int structSize2 = sizeof(struct perInfo2);
    printf("Size : { int, char[10], double } = %d\n",structSize1);
    printf("Size : { char[10], double, int } = %d\n",structSize2);
    return 0;
}
```

###### 输出结果：

```c
当最前加#pragma pack(8) 让编译器默认对齐数为8：
Size : { int, char[10], double } = 24
Size : { char[10], double, int } = 32
    
当最前加#pragma pack(4) 让编译器默认对齐数为4：
Size : { int, char[10], double } = 24
Size : { char[10], double, int } = 24
```

###### 解析：

当编译器默认对齐数为8：`#pragma pack(8)`

[![GcO6iV.md.jpg](https://s1.ax1x.com/2020/04/07/GcO6iV.md.jpg)](https://imgchr.com/i/GcO6iV)



![GcOWM4.jpg](https://s1.ax1x.com/2020/04/07/GcOWM4.jpg)

###### 字节对齐总结

https://shimo.im/docs/ydYJdGQqkHhV6ckP/ 



## 3.8

```c
int main()
{
	int a[4] [3]={1,2,3,4,5,6,7,8,9,10,11,12};
	// 假设 a的首地址为0x0000000000000000
    printf("%p,%p\n",a,a+1);
    printf("%p,%p\n",a[0],a[0]+1);
    printf("%p,%p\n",*a,*a+1);
    printf("%d\n",a[0] [0]);
    printf("%d,%d\n",*a[0],*(a[0]+1));
    printf("%d\n",**a);
    printf("%d\n",* (*(a+3)+1));
    
}
```

###### 输出结果：

```c
0x0000000000000000	0x000000000000001c
0x0000000000000000  0x0000000000000004
0x0000000000000000  0x0000000000000004    
1
1,2
1
11
```

###### 考点：

指针的加减



分析：
